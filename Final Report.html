<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ManiMAtCha: Mesh-Level Differentiable Chart-Based Rendering</title>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #fff; color: #333; margin: 0; padding: 0; }
    .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; }
    h1 { font-size: 2.5rem; color: #005a9c; margin-bottom: 10px; }
    h2 { font-size: 1.8rem; margin-top: 40px; color: #004777; border-bottom: 2px solid #e0e0e0; padding-bottom: 8px; }
    h3 { font-size: 1.4rem; margin-top: 30px; color: #004777; }
    p { line-height: 1.6; margin: 16px 0; }
    ol, ul { margin: 16px 0 16px 40px; }
    li { margin-bottom: 8px; }
    pre { background: #f4f4f4; padding: 15px; border-radius: 4px; overflow-x: auto; }
    code { font-family: Consolas, 'Courier New', Courier, monospace; background: #e8e8e8; padding: 2px 4px; border-radius: 3px; }
    img { max-width: 100%; height: auto; border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); margin: 20px 0; }
    .references li { margin-bottom: 6px; }
    a { color: #0066cc; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .footer { text-align: center; margin-top: 60px; font-size: 0.9rem; color: #777; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ManiMAtCha</h1>
    <p><strong>Mesh-Level Differentiable Chart-Based Rendering</strong></p>

    <h2>Abstract</h2>
    <p>We augment MAtCha’s Gaussian chart pipeline with a differentiable mesh loss inspired by NeuManifold, sharpening reconstructions from sparse views with minimal overhead.</p>

    <h2>Technical Approach</h2>
    <p>We extend MAtCha’s chart-based reconstruction by freezing charts post-alignment and applying a differentiable mesh-based loss to refine Gaussian surface elements.</p>

    <h3>Baseline: MAtCha Pipeline</h3>
    <p>MAtCha predicts per-view depth, backprojects to charts aligned via SfM, initializes Gaussians, and jointly optimizes geometry and color.</p>

    <h3>Mesh-Regularization Extension</h3>
    <p>Charts are fixed; every few iterations we extract a mesh via differentiable Marching Cubes, render it, and backpropagate a mesh render loss into Gaussian parameters.</p>
    <pre><code># Mesh regularization
mesh_render_loss = 0
# if iteration > 6900 and iteration % 5 == 0:
if True:
    # Mesh regularization
    print("[INFO] Extracting mesh...")
    device = 'cuda'
    from utils.mesh_utils import GaussianExtractor
    gaussExtractor = GaussianExtractor(gaussians, render, pipe, bg_color=bg_color)    
    gaussExtractor.reconstruction(scene.getTrainCameras())
    verts, faces, vert_colors = gaussExtractor.extract_mesh_unbounded2(resolution=512)
    import gc; gc.collect(); torch.cuda.empty_cache()
    from matcha.dm_scene.meshes import Meshes, TexturesVertex
    p3d_mesh = Meshes(
        verts=[verts], 
        faces=[faces.long()],
        textures=TexturesVertex([vert_colors]),
    )
    scene_cameras = scene.getTrainCameras()
    from matcha.dm_scene.cameras import CamerasWrapper, GSCamera
    gs_cameras = []
    for scene_camera in scene_cameras:
        gs_cameras.append(GSCamera(
            colmap_id=scene_camera.colmap_id,
            R=scene_camera.R,
            T=scene_camera.T,
            FoVx=scene_camera.FoVx,
            FoVy=scene_camera.FoVy,
            image=scene_camera.original_image,
            gt_alpha_mask=scene_camera.gt_alpha_mask,
            image_name=scene_camera.image_name,
            uid=scene_camera.uid,
            data_device=scene_camera.data_device,
            image_height=scene_camera.image_height,
            image_width=scene_camera.image_width,
        ))
    cameras_wrapper = CamerasWrapper(gs_cameras)
    from matcha.dm_scene.meshes import render_mesh_with_pytorch3d
    result = render_mesh_with_pytorch3d(p3d_mesh, cameras_wrapper, 0)
    rgb_image = result['rgb']
    from PIL import Image
    Image.fromarray((rgb_image.detach().cpu().numpy() * 255).astype(np.uint8)).save(f"mesh_{iteration}_rgb.png")
    gt_image = scene_cameras[0].original_image.permute(1, 2, 0)
    mesh_render_loss = torch.mean((rgb_image - gt_image) ** 2)
    total_loss = total_loss + total_regularization_loss + 5 * mesh_render_loss
else:
    total_loss = total_loss + total_regularization_loss
</code></pre>

    <h3>Implementation Challenges</h3>
    <ul>
      <li>High memory & computation for mesh extraction: mitigated via reduced resolution and cache clearing.</li>
      <li>Hole artifacts from frozen charts: addressed by exploring mild Gaussian coverage regularization.</li>
    </ul>

    <h3>Lessons Learned</h3>
    <ul>
      <li>Decoupling charts and Gaussian refinement simplifies design but can cause alignment instabilities.</li>
      <li>Mesh loss improves accuracy at the cost of computation; batching and memory management are essential.</li>
      <li>Freezing charts enforces modularity but requires strong initial geometry to avoid holes.</li>
    </ul>

    <h2>Results</h2>
    <h3>Qualitative</h3>
    <img src="images/matcha_baseline.png" alt="Baseline render">
    <img src="images/matcha_meshloss.png" alt="ManiMAtCha render">
    <p><em>Figure 1:</em> Baseline vs ManiMAtCha render.</p>

    <h3>Quantitative</h3>
    <p>Metrics (PSNR, Chamfer distance, etc.) to be added.</p>

    <h2>References</h2>
    <ol class="references">
      <li>Guédon, Antoine, Tomoki Ichikawa, Kohei Yamashita, and Ko Nishino. “MAtCha Gaussians: Atlas of Charts for High-Quality Geometry and Photorealism From Sparse Views.” <em>Proceedings of CVPR</em>, 2025.</li>
      <li>Wei, Xinyue, Fanbo Xiang, Sai Bi, Anpei Chen, Kalyan Sunkavalli, Zexiang Xu, and Hao Su. “NeuManifold: Neural Watertight Manifold Reconstruction with Efficient and High‑Quality Rendering Support.” <em>ArXiv</em> preprint arXiv:2305.17134, 2023.</li>
    </ol>

    <div class="footer">&copy; 2025 Team ManiMAtCha. All rights reserved.</div>
  </div>
</body>
</html>
